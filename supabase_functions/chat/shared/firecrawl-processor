/**
 * Procesador de URLs con Firecrawl
 * Scrape eventos desde URLs descubiertas por Tavily
 */

import { createClient, SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { geocodeWithFallback } from './geocoding.ts';

interface ProcessedEvent {
  title: string;
  description?: string;
  event_date?: string;
  event_time?: string;
  venue_name?: string;
  venue_address?: string;
  district?: string;
  price_text?: string;
  price_min?: number;
  price_max?: number;
  is_free?: boolean;
  source_url: string;
  image_url?: string;
  category?: string;
}

/**
 * Procesa una URL con Firecrawl para extraer eventos
 */
export async function processUrlWithFirecrawl(
  url: string,
  firecrawlApiKey: string
): Promise<ProcessedEvent[]> {
  try {
    console.log(`[Firecrawl] Processing URL: ${url}`);

    const schema = {
      type: 'object',
      properties: {
        events: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              title: { type: 'string' },
              description: { type: 'string' },
              date: { type: 'string' },
              time: { type: 'string' },
              venue: { type: 'string' },
              location: { type: 'string' },
              price: { type: 'string' },
              category: { type: 'string' },
              imageUrl: { type: 'string' },
            },
            required: ['title']
          }
        }
      }
    };

    const response = await fetch('https://api.firecrawl.dev/v1/scrape', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${firecrawlApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        url,
        formats: ['extract'],
        extract: {
          schema,
          systemPrompt: `Extract cultural event information from this page.
Focus on events in Peru (Lima). Extract: title, description, date, time, venue, location, price, category.
If this page contains multiple events, extract all of them.
If it's a single event page, extract that one event with all details.`
        }
      })
    });

    if (!response.ok) {
      throw new Error(`Firecrawl API error: ${response.statusText}`);
    }

    const result = await response.json();

    if (!result.success || !result.data?.extract?.events) {
      console.log(`[Firecrawl] No events found in ${url}`);
      return [];
    }

    const events = result.data.extract.events
      .map((event: any) => processEvent(event, url))
      .filter((event: any) => event !== null);

    console.log(`[Firecrawl] Extracted ${events.length} events from ${url}`);
    return events;

  } catch (error) {
    console.error(`[Firecrawl] Error processing ${url}:`, error);
    return [];
  }
}

/**
 * Procesa y normaliza datos de un evento extraído
 */
function processEvent(eventData: any, sourceUrl: string): ProcessedEvent | null {
  try {
    const title = eventData.title?.trim();
    if (!title) return null;

    const description = eventData.description?.trim();
    const venueName = eventData.venue?.trim();
    const location = eventData.location?.trim();
    const priceText = eventData.price?.trim();
    const imageUrl = eventData.imageUrl;
    const category = eventData.category?.trim();

    // Parse date
    const eventDate = parseDate(eventData.date);

    // Parse time
    const eventTime = normalizeTime(eventData.time);

    // Parse price
    const priceInfo = parsePrice(priceText);

    // Extract district
    const district = extractDistrict(location || venueName);

    return {
      title,
      description,
      event_date: eventDate,
      event_time: eventTime,
      venue_name: venueName || location,
      venue_address: location,
      district,
      price_text: priceInfo.price_text,
      price_min: priceInfo.price_min,
      price_max: priceInfo.price_max,
      is_free: priceInfo.is_free,
      source_url: sourceUrl,
      image_url: imageUrl,
      category: category || 'General',
    };

  } catch (error) {
    console.error('[Firecrawl] Error processing event:', error);
    return null;
  }
}

/**
 * Inserta eventos en Supabase con geocoding
 */
export async function insertEventsToDatabase(
  events: ProcessedEvent[],
  supabase: SupabaseClient,
  sourceName: string = 'Tavily Discovery'
): Promise<{ inserted: number; errors: string[] }> {
  let inserted = 0;
  const errors: string[] = [];

  for (const event of events) {
    try {
      // Geocode the event location
      let latitude = null;
      let longitude = null;

      if (event.venue_address || event.district) {
        const geoResult = await geocodeWithFallback(
          event.venue_address || '',
          event.district || '',
          'Lima'
        );

        if (geoResult) {
          latitude = geoResult.latitude;
          longitude = geoResult.longitude;
          console.log(`[Geocoding] "${event.title}": ${latitude}, ${longitude}`);
        }

        // Rate limiting
        await new Promise(resolve => setTimeout(resolve, 1000));
      }

      const { data, error } = await supabase
        .from('events')
        .insert({
          title: event.title,
          description: event.description,
          category: event.category,
          event_date: event.event_date,
          event_time: event.event_time,
          venue_name: event.venue_name,
          venue_address: event.venue_address,
          district: event.district,
          price_text: event.price_text,
          price_min: event.price_min,
          price_max: event.price_max,
          is_free: event.is_free,
          source_name: sourceName,
          source_url: event.source_url,
          image_url: event.image_url,
          city: 'Lima',
          is_active: true,
          latitude,
          longitude,
        })
        .select('id')
        .single();

      if (error) {
        console.error(`[DB] Error inserting "${event.title}":`, error);
        errors.push(`${event.title}: ${error.message}`);
      } else {
        inserted++;
        console.log(`[DB] Inserted event #${data.id}: ${event.title}`);
      }

    } catch (insertError: any) {
      console.error('[DB] Insert error:', insertError);
      errors.push(`${event.title}: ${insertError.message}`);
    }
  }

  return { inserted, errors };
}

/**
 * Parse date string to ISO format
 */
function parseDate(dateStr?: string): string | null {
  if (!dateStr) return null;

  try {
    const date = new Date(dateStr);
    if (!isNaN(date.getTime())) {
      return date.toISOString();
    }
    return null;
  } catch {
    return null;
  }
}

/**
 * Normalize time string
 */
function normalizeTime(timeStr?: string): string | null {
  if (!timeStr) return null;
  return timeStr.trim();
}

/**
 * Parse price information
 */
function parsePrice(priceText?: string): {
  price_text: string | null;
  price_min: number | null;
  price_max: number | null;
  is_free: boolean;
} {
  if (!priceText) {
    return { price_text: null, price_min: null, price_max: null, is_free: false };
  }

  const priceLower = priceText.toLowerCase();

  // Check if free
  const isFree = /gratis|free|entrada libre|sin costo/i.test(priceLower);
  if (isFree) {
    return { price_text: priceText, price_min: 0, price_max: 0, is_free: true };
  }

  // Extract numbers
  const numbers = priceText.match(/\d+(?:,\d{3})*(?:\.\d{2})?/g);
  const prices = numbers ? numbers.map(n => parseFloat(n.replace(/,/g, ''))) : [];

  return {
    price_text: priceText,
    price_min: prices.length > 0 ? Math.min(...prices) : null,
    price_max: prices.length > 0 ? Math.max(...prices) : null,
    is_free: false,
  };
}

/**
 * Extract district from address
 */
function extractDistrict(address?: string): string | null {
  if (!address) return null;

  const districts = [
    'Miraflores', 'San Isidro', 'Barranco', 'Surco', 'La Molina',
    'San Borja', 'Jesús María', 'Lince', 'Magdalena', 'Pueblo Libre',
    'San Miguel', 'Cercado de Lima', 'Lima', 'Breña', 'Chorrillos',
    'Surquillo', 'San Luis', 'La Victoria', 'Rímac', 'Callao',
  ];

  const addressLower = address.toLowerCase();
  for (const district of districts) {
    if (addressLower.includes(district.toLowerCase())) {
      return district;
    }
  }

  return null;
}
